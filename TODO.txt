rice is life {{{
 
 - single-letter messages
   - 00:10 NOTICE(NickServ->tso): This nickname is registered... becomes
     00:10N(NickServ->tso): This nickname is registered...

 - use nick color as background color for nickflash
   - use contrast()

 - themes
   - background/foreground color need to be applied to:
     - nicklistbox bg[ ] fg[ ]
     - status bar  bg[x] fg[ ]
     - richedit    bg[x] fg[ ]
     - tabs        bg[ ] fg[ ]
     - linedit     bg[ ] fg[ ]
     - pushbutton  bg[ ] fg[ ]
     - tableview   bg[ ] fg[ ]
   - need abstraction for above in order to load new palette whenever
   - selectable font (oh god)

 - win98 status bar icons

 - set richedit font to Universalia 8pt if any unicode in text
   - or around unicode bits of text only 

}}}
---
keyboard shortcuts {{{
    - ctrl+q:     exit application
    - alt+f4:     exit application
    - ctrl+m:     hide to tray
    - ctrl+t:     open/switch to empty server tab
    - ctrl+f4:    close current tab
    - ctrl+w:     close current tab
    - ctrl+f:     search textBuffer
    - ctrl+enter: insert \n
}}}
---
tabwidget {{{
        
NOTE(tso): not possible to get mouse or keyboard events on TabWidget afaict
so rip the dream:
 - mouse
     - middle-click to close tabs
     - scroll to cycle through tabs
     - context menu
        - mark as read
        - close

 - automatic tab sort order 
    - alphabetical
    - most activity
}}}
---
BUGS(panic at the disco): {{{

 - wat
panic: invalid hdc

Stack:

1: running [locked]
    debug   stack.go:24            Stack(0xc042504af8, 0xc042504b18, 0x4466f8)
    walk    error.go:81            newErr(string(0x8758aa, len=11), 0x2, #1)
    walk    error.go:85            newError(string(0x8758aa, len=11), 0x18, 0xc042504b88)
    walk    canvas.go:109          newCanvasFromHDC(HDC(0x0), #1, 0xc042504bf8)
    walk    container.go:304       (*ContainerBase).doPaint(*ContainerBase(#7), 0x0, 0x0)
    walk    container.go:378       (*ContainerBase).WndProc(*ContainerBase(#7), HWND(#1), 0, uintptr(0x0))
    walk    window.go:1492         defaultWndProc(HWND(#1), 0, uintptr(0x0))
    syscall syscall_windows.go:184 Syscall6(uintptr(#3), uintptr(0x9100a), uintptr(0xf003), uintptr(0x0), uintptr(0x0), ...)
    win     user32.go:1947         DefWindowProc(HWND(0x9100a), 61443, uintptr(0x10655))
    walk    window.go:1819         (*WindowBase).WndProc(*WindowBase(#6), HWND(0x9100a), 61443, uintptr(0x10655))
    walk    form.go:692            (*FormBase).WndProc(*FormBase(#6), HWND(0x9100a), 61443, uintptr(0x10655))
    walk    mainwindow.go:226      (*MainWindow).WndProc(*MainWindow(#6), HWND(0x9100a), 61443, uintptr(0x10655))
    walk    window.go:1492         defaultWndProc(HWND(0x9100a), 61443, uintptr(0x10655))
    syscall syscall_windows.go:184 Syscall6(uintptr(#3), uintptr(0x9100a), uintptr(0xc), uintptr(0x0), uintptr(0x0), ...)
    win     user32.go:1947         DefWindowProc(HWND(0x9100a), 12, uintptr(0x10655))
    walk    window.go:1819         (*WindowBase).WndProc(*WindowBase(#6), HWND(0x9100a), 12, uintptr(0x10655))
    walk    form.go:692            (*FormBase).WndProc(*FormBase(#6), HWND(0x9100a), 12, uintptr(0x10655))
    walk    mainwindow.go:226      (*MainWindow).WndProc(*MainWindow(#6), HWND(0x9100a), 12, uintptr(0x10655))
    walk    window.go:1492         defaultWndProc(HWND(0x9100a), 12, uintptr(0x10655))
    syscall syscall_windows.go:171 Syscall(uintptr(#2), uintptr(0x9100a), uintptr(0x0), uintptr(0x0))
    win     user32.go:2376         IsDialogMessage(HWND(0x9100a), *MSG(0x0))
    walk    form.go:397            (*FormBase).Run(*FormBase(#6), 0x0)
    main    main.go:185            main()
1: running [locked]
    walk    container.go:379       (*ContainerBase).WndProc(#7, #1, 0xf, 0, 0, 0)
    walk    window.go:1492         defaultWndProc(HWND(#1), 0, uintptr(0x0))
    syscall syscall_windows.go:184 Syscall6(uintptr(#3), uintptr(0x9100a), uintptr(0xf003), uintptr(0x0), uintptr(0x0), ...)
    win     user32.go:1947         DefWindowProc(HWND(0x9100a), 61443, uintptr(0x10655))
    walk    window.go:1819         (*WindowBase).WndProc(*WindowBase(#6), HWND(0x9100a), 61443, uintptr(0x10655))
    walk    form.go:692            (*FormBase).WndProc(*FormBase(#6), HWND(0x9100a), 61443, uintptr(0x10655))
    walk    mainwindow.go:226      (*MainWindow).WndProc(*MainWindow(#6), HWND(0x9100a), 61443, uintptr(0x10655))
    walk    window.go:1492         defaultWndProc(HWND(0x9100a), 61443, uintptr(0x10655))
    syscall syscall_windows.go:184 Syscall6(uintptr(#3), uintptr(0x9100a), uintptr(0xc), uintptr(0x0), uintptr(0x0), ...)
    win     user32.go:1947         DefWindowProc(HWND(0x9100a), 12, uintptr(0x10655))
    walk    window.go:1819         (*WindowBase).WndProc(*WindowBase(#6), HWND(0x9100a), 12, uintptr(0x10655))
    walk    form.go:692            (*FormBase).WndProc(*FormBase(#6), HWND(0x9100a), 12, uintptr(0x10655))
    walk    mainwindow.go:226      (*MainWindow).WndProc(*MainWindow(#6), HWND(0x9100a), 12, uintptr(0x10655))
    walk    window.go:1492         defaultWndProc(HWND(0x9100a), 12, uintptr(0x10655))
    syscall syscall_windows.go:171 Syscall(uintptr(#2), uintptr(0x9100a), uintptr(0x0), uintptr(0x0))
    win     user32.go:2376         IsDialogMessage(HWND(0x9100a), *MSG(0x0))
    walk    form.go:397            (*FormBase).Run(*FormBase(#6), 0x0)
    main    main.go:185            main()

 - make sure strings never have \0 in them:

<- :Term1nal!~metal@unaffiliated/f41l QUIT :Quit: Term1nal
panic: syscall: string with NUL passed to StringToUTF16


To see all goroutines, visit https://github.com/maruel/panicparse#GOTRACEBACK

1: running [locked]
    syscall syscall_windows.go:29 StringToUTF16(#3, 0xa, 0x1, 0xc0423ae0c0, 0x1)

    syscall syscall_windows.go:64 StringToUTF16Ptr([]uint16(#3 len=10 cap=825747252801))
    walk    listbox.go:120        (*ListBox).insertItemAt(*ListBox(#2), 2, 0x0, 0x0)
    walk    listbox.go:146        (*ListBox).resetItems(*ListBox(#2), 0x0, 0x0)
    walk    listbox.go:160        (*ListBox).attachModel.func1()
    walk    event.go:58           (*EventPublisher).Publish(*EventPublisher(#1))

    walk    models.go:51          (*ListModelBase).PublishItemsReset(*ListModelBase(#1))
    main    tab_channel.go:83     (*tabChannel).updateNickList.func1()
    walk    form.go:56            runSynchronized()
    walk    form.go:402           (*FormBase).Run(*FormBase(0xc0420b6a80), 0x0)
    main    main.go:182           main()
}}}
---
BUGS(uncategorized): {{{
 - click to change tab from channelList causes crash
   - ctrl+tab works just fine
   - didn't try closing it

 - WM_VSCROLL hack fires even when textBuffer has keyboard focus
   OR call to SetTextSelection() in AppendText() is doing it
   either way you can't scroll in a super active channel which is the only
   time you really need scroll

 - channelList not populated sometimes
   - 321 ALWAYS comes before 322 
     but if goirc.HandleFunc is just doing go handler() indiscriminately
     which would cause a 322 to get handled before a 321 sometimes at random
     that's another reason to get rid of goirc

     because we *do* want to ignore 322 if the channelList tab was closed atm

     NOTE(tso): unrelated
     userstory storytime:
        " hey what channels are on this network
        " oh shit there are 20,000
        " */list*
        " *server sends 20,000 lines*
        " let's sort by most popular oh this one looks good
        " *closes channel list tab*
        " *client is still receiving 20,000 lines*
        " oh nvm this channel is dead let's see that list again
        " /list

        WHAT SHOULD HAPPEN CHOOSE YOUR ADVENTURE:

        [1] "still getting list results from last time, try again later"
        (what we do now)

        [2] display the still-incoming list results as-is 
        (confusing to user)

        [3] always store all of the list results in a separate array on
            serverState structure instead of relying on channelListModel
            and add a Refresh button to channelList 
            which is disabled until we get ENDOFLIST (323 I assume)
        (A WINNER IS YOU)

        we're basically just recreating xchat at this point

    -tso 7/13/2018 10:27:54 PM

  - tab close behavior is screwy but I don't want to mess with it rn

  - major: sync issues
    - grep -r HACK for more information

  - minor but looks really bad: adding/closing tabs to window causes ui
    flicker

  - nickflash/highlight should be case insensitive

}}}

richedit {{{

FIX PROBLEMS:
 - richedit jumps up like 20 lines or scrolls past the end find out whats
   going on with that it has to do with when its focused or not
   dont just spam WM_VSCROLL although thats probably the solution

 - appendtext/linecount

CREATE NEW PROBLEMS:
 - /search or /find or CTRL+F
    - perfect world: reduce text buffer to matches, then restore
    - real world: jump to selection
 
 - selection automatically goes to clipboard
}}}
---
(*actual todo list) {{{

 - /part without closing tab
     - chanState tracks whether "connected" to channel?

 - split extra long text input
     - maxlen is 450..512
     - ctrl+enter inserts \n
     - split on \n, send multiple lines
     - dialog box: warn about sending > 2 lines

 - don't log lines if DISCONNECTED

 - don't display lines if not sent
    - e.g. cannot send to channel (+m)

 - don't open privmsg tab if not sent
    - e.g. no such nick/channel
}}}
---
walk {{{

 - system tray icon
     - notifications balloons for highlight (if !mainWindowFocused)
       CONTEXT MENU:
         - list of current networks and channels (and privmsgs) !!
         - settings
         - about
         - report issue
         - quit

 - figure out how to make the window flash orange in the task bar
}}}
---
new feature {{{

 - topic widget should allow input and send /topic or whatever
   after: replace topicInput with a RichEdit to display colors and links 

 - highlight list
    - probably should compile regexp for that since its more complex
    - needs dialog, maybe just use TextEdit
    - support for patterns

 - word filter
    - e.g. "fuck" => "****"
    - or 4chan style "fam" => "desu"

 - limit scrollback to n lines

 - load chatlog on join
}}}
---
big project/refactor {{{

 - new server tab/connection abstraction

 - make empty server tab possible

 - use nick type instead of nick as string in more places
   - store color value in nickList
}}}
---
commands {{{

 - /mode needs to be able to send just the channel e.g. MODE #test
   to get a reply of what the mode is
   expected: /mode #channel
             Mode for #channel is +CSnpstz
             /mode tso
             tso (221: +Sirx)

 - ditto for /topic
   expected: /topic
             Topic for #channel is "words" set by tso at 7/12/2018 11:54:18 PM

 - /welcome
    - first run welcome message
    - ascii art logo
    - contact + link to github
    - getting started
      /server irc.example.org +
      /join #channel
      hi
    - /help for more information

 - tab completion for commands

need dialog box for better management of lists:
 - /ignore
    - /unignore
 - /invite
    - /uninvite
 - /kickban

}}}
---
improvements {{{

 - better scripting examples
    - useful/common things: rainbow text, automatic translation, emoticons
}}}
---
config {{{

 - autoload registered scripts at startup

 - settings dialog
 
 - write to config.json
     - save current state as autojoin on exit (optional)

 - hidejoinparts per channel(with list) or global

 - ignore list

 - highlight list
    - disable highlight
}}}
---
dcc {{{

 - /send 

 - file transfers tab
 
 - Save As dialog on recv

 - drag/drop

 unrelated: maybe turn tsobot into a XDCC bot
}}}
---
extensions {{{

 - inline twitter links

 - be able to connect to irc.twitch.tv (implement OAUTH or whatever they use)
}}}
---
bikeshedding {{{

 - testing
     - it would be nice if we could test the UI 
       without having to connect to a network 
         - one of each type of tab opens up 
         - each with examples of every type of information it can display in
           all states
         - just for the sake of designing
         - doesn't have any logic
         - separate application
         - would probably have to split project into subpackages (yuck)
           - no wait we could do what we did when testing richedit
             // +build ignore
             
             go build testapp.go *:not(main) # wait this isn't css

     - it would be nice if we could test the logic by faking a connection e.g.
       by sending raw IRC lines e.g.
       ":host@nowhere PRIVMSG #fakechannelfortesting :test\n"
       on a simple channel or something so there's nothing complicated about
       mocking a connection if only it were that easy

 - replace goirc with simple channels and goroutines
    yay:
         - /reconnect is impossible for some reason
         - logger interface is inconvenient
         - no convenient way to capture unhandled server messages 
         - it would be trivial to mock connections by just sending raw IRC
           lines on the recv chan
           see MockConnection() in irc/irc.go
         - all handlers run in their own goroutines so even though messages
           always come in in a particular order the handlers can run in any
           order which is causing me all sorts of issues 
            - with LIST sometimes we get a LIST result before LISTSTART so the
              channellist tab hasn't been created yetbut the server sent
              LISTSTART first.
            - with NAMES and 332 sometimes one comes before the other and we
              need to create the channel tab in either case (and not on JOIN
              because user could have mode +b or channel could be +s) so it's
              a race condition and conceivably two tabs could open though I
              haven't seen that happen yet (I was consistently not getting 332
              displaying in the buffer but that was because the tab creation
              itself happens asynchronously as well)
            - this could all be a misunderstanding on my part but I'm pretty
              sure it would be better to dispatch handlers asynchronously only
              if/when the ui state is known instead of having to sync up
              inside of those handlers
              of course it would be much easier to understand if we just did
              everything line-by-line and didn't introduce goroutines at all
              but I worry that would cause a laggy/unresponsive chat
              experience like cybits used to exhibit whenever an http request
              took a long time.

              I don't see how it would be a problem to just:
              
              line := <-recv
              cmd, args := parseLine(line)
              switch cmd {
              // ...
              case PRIVMSG:
                if !tabExists(args.dest) {
                    createTab(args.dest)
                }
                go privmsgHandler(args)

                like I want to believe that would solve everything and seems
                less pants-on-head than

                go privmsgHandler()

                func privmsgHandler{
                    if !tabExists ...

                    like we're doing now

            like I don't get how doing some blocking stuff for a few cycles
            that's necessary to have a consistent state is a bad thing what am
            I missing?

    nay:
         - it works
         - has anti-flooding stuff
         - line parsing might be harder than it looks

 - replace walk with qt 
    ... for version 2.0

    yay:
         - inline images for emojis and embedding thumbnails 
         - richedit is hella annoying
         - can't capture global mouse/key events because child widgets steal
           focus
         - can't get mouse/key events on tabs in widget or apply custom
           background/text color/etc without reimplementing entire widget

    nay:
        - walk is hella comfy (it just worksة)
        - sunken cost fallacy (I've spent a lot of time getting stuff to work)
        - batteries included
            - screenshots
            - autourl detect
        
 - irc bouncer (separate project)
     - use public/private key pairs for authentication or something
     - basically just a relay/proxy that PING/PONGs when the user isn't connected
     - stores messages while user isn't connected, dumps (user configurable
       amount) on reconnect
     - autoreply or maybe just (Away)!
     - *** this sort of thing might be against IRC network rules need to look into
       what the policy is and/or how znc does it so well
       or just use znc

}}}
░░░
RESOURCES: {{{

IRC:
http://modern.ircdocs.horse/

Tabs:

    About Tab Controls | Microsoft Docs
https://docs.microsoft.com/en-us/windows/desktop/Controls/tab-controls#tc_image_lists

    Hacking the Overall Background Color of a Windows Tab Control
http://www.glennslayden.com/code/win32/tab-control-background-brush


RichEdit stuff:
https://docs.microsoft.com/en-us/windows/desktop/Controls/bumper-rich-edit-rich-edit-control-reference
https://docs.microsoft.com/en-us/windows/desktop/api/Richedit/ns-richedit-tagrichedit_image_parameters
https://docs.microsoft.com/en-us/windows/desktop/api/Richedit/ns-richedit-_charformat
https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/DynamicDPI/cpp/SampleRichEditControl.cpp
https://docs.microsoft.com/en-us/windows/desktop/Controls/em-geteditstyle
https://docs.microsoft.com/en-us/windows/desktop/Controls/em-seteventmask
https://docs.microsoft.com/en-us/windows/desktop/Controls/rich-edit-control-event-mask-flags
https://docs.microsoft.com/en-us/windows/desktop/Controls/em-geteditstyleex
https://github.com/Alexpux/mingw-w64/blob/master/mingw-w64-headers/include/richedit.h
https://blogs.msdn.microsoft.com/murrays/2015/03/27/richedit-colors/

Useful:
    open urls from command line in any OS:
https://www.dwheeler.com/essays/open-files-urls.html

    get tab key messages in windows:
http://forums.codeguru.com/showthread.php?60142-How-to-trap-WM_KILLFOCUS-with-Tab-key

    numerical values for Windows constants e.g. LONG DWORD LPSTR etc:
https://doc.pcsoft.fr/en-US/?6510001
https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types

    window styles
https://msdn.microsoft.com/en-us/library/windows/desktop/ms632600(v=vs.85).aspx

    setlayeredwindowattributes (transparency)
    example code:
https://msdn.microsoft.com/en-us/library/ms997507.aspx
    reference:
https://msdn.microsoft.com/en-us/library/windows/desktop/ms633540(v=vs.85).aspx

    might be what we're looking for:
https://docs.microsoft.com/en-us/windows/desktop/api/dwmapi/nf-dwmapi-dwmextendframeintoclientarea

}}}
▒▒▒
ADDENDUM: {{{

RE: inserting images in RichEdit

nvm OLE is exceptionally awful and I can't figure out how to get the
OBJECTPOSITIONS messages so fuck it if we want more out of the UI than pretty
colors there's always walk.WebView, electron, Qt, or reinventing the wheel
(render text and handle pointer events for text selection and put stuff on the
clipboard manually and invent a scrollbar and waste like a solid year on that)

-tso, July Sun Jul 8 07:49:26 2018 -0400

RE: splitting main into subpackages

or "issues nobody raised yet but inevitably will part 1"

who's going to import and use github.com/generaltso/chopsuey/widgets
or github.com/generaltso/chopsuey/colors or messages or whatever?
nobody that's who because most of this code is specific to this application

if the argument is well you should make the code decoupled for reuse,
who other than another client or an overly complicated bot is going 
to use this code? authors of those things tend to want to roll their own
anyway. 

if it's for testing purposes, there's no reason not to add tests for
the main package since `go test` doesn't call main and most things are
testable as they are right now (with the notable exception of not being able
to mock the serverConnection which will go away if/when I replace goirc)

and if the argument is it will make the code easier to maintain I would kindly
ask for an example because I've never seen a project where having to grep -r
(or is it -R) and jump around multiple files in multiple directories trying to
figure out where functions are called and things are happening makes anything
easier to understand

Furthermore, worrying about which symbols need to be exported or needing to
use .mod files is an undue source of complexity and headaches for a project of
this scope

Splitting an **application** into multiple subpackages is an antipattern imho
unless that application has what are effectively its own libraries that are
potentially useful for other applications to import. In that case, I'm not
opposed to the idea, in fact I made a basic webapp framework based on what I
did in caffochoco and caffochoco-mythril (I lost what I think was the only copy
of the code to a hard drive crash...) but in that case where you can get
started on a new application by just import'ing what you already have *is*
really useful but tbh that's simply not the case here and separating all that
logic would be a lot of work for literally no gain, the examples provided with
walk are better at showing how to scaffold a new app 

If you follow what I'm saying then you'll understand why the (go) channels-
based irc connection is its own package

If you're still convinced I'm wrong I encourge you to refactor everything
yourself and fork (off)

WONTFIX
-tso 7/14/2018 8:14:06 AM

}}}

# vim: tw=70 ft=help fdm=marker fmr={{{,}}} fdl=0 fen:
